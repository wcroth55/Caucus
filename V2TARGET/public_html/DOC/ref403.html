<HTML>
<HEAD>
<TITLE>CML Reference Guide 4.4: Files</TITLE>
<link rel="stylesheet" type="text/css" href="cml.css">
</HEAD>

<BODY BGCOLOR="#FFFFFF">

<CENTER>
<H2>CML Reference Guide</H2>
</CENTER>

<BLOCKQUOTE>
<TABLE CELLSPACING=0 CELLPADDING=0 WIDTH=90%>
<TR VALIGN=top>
<TD><H2>Chapter 4.3:&nbsp; File Access</H2></TD>
<TD ALIGN=right>
   [<A HREF="index.html">TOP</A>]
   [<A HREF="ref4.html">UP</A>]
   [<A HREF="ref402.html">PREV</A>]
   [<A HREF="ref404.html">NEXT</A>]
</TD>
</TABLE>


<DL>
<P><DT><A NAME="includecml">$includecml (name [iargs])</A>
<DD>Parse the contents of a CML file <I>name</I> as though
it had been "included" by an 
<A HREF="ref5.html#include">include directive</A> at this point.&nbsp;
<I>Name</I> is relative to the top CML directory, 
as defined in <A HREF="ref402.html#cml_path">$cml_path()</A>.&nbsp;
<I>Iargs</I> is an optional list of tokens that will be expanded
inside <I>name</I> as 
<A HREF="ref401.html#inc">$inc(1)</A>, $inc(2), etc.
<P>
A call to $includecml() evaluates to the "output" generated by
double-quote lines in CML file <i>name</i>.&nbsp;
So the "output" generated by <i>name</i> is <b>not</b> sent
to the browser (or stdout, if run from sweba).&nbsp;
This is how $includecml() "returns" values computed by <i>name</i>.
<p>
Notes:
<OL>
<LI>The <A HREF="ref5.html#quit">quit</A> directive acts like
a <A HREF="ref5.html#return">return</A> directive inside such
an included file.
<P>
<LI>This is a very powerful extension to Caucus (in version 4.23), especially
when combined with Caucus "macros", since a macro can now
effectively execute any Caucus directives, including for and count
loops, etc.
<P>
<LI>There are some unanswered security questions about this function.&nbsp;
Future versions may put more explicit restrictions on which files
can be included.&nbsp;
Unfortunately, <A HREF="ref402.html#protect">$protect()</A> is
too blunt an instrument to be much help with this.
</OL>


<P><DT><A NAME="file">$file(name)</A>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B><A 
   HREF="ref402.html#protect">{protected}</A></B>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<I>(Probably obsoleted by $includecml().)</I>
<DD>
Include the entire text of file <I>name</I> at this point.

<P>
The $file() function should only be used to include relatively
short (a couple of lines, maximum) files, such as when you need
to include the contents of a file in the middle of an HTML or
SET string that you are building.&nbsp;  <I>Name</I> is relative to
the CML_Path directory specified in the swebd.conf file.&nbsp;  (See
the Caucus installation guide for details.)&nbsp;
Any CML functions inside <I>name</I> are interpreted, by
CML directives are not.

<P>
If you need to include a large file, or one that contains CML
directives, see the <A HREF="ref5.html#include">include</A>
directive, or $includecml() above.

<P><DT><A NAME="include">$include (name)</A>
<DD><I>(Obsoleted by $includecml().)</I>&nbsp;
Include contents of CML file <I>name</I>.&nbsp;
Very limited and probably buggy.&nbsp;
Do not use.

<P><DT><A NAME="readterm">$readterm()</A>
<DD>
Reads a single line of text from the user's terminal, removes
the trailing newline, and evaluates to that line as a string.
<P>
This function is only useful with sweba, the stand-alone 
CML interpreter.&nbsp;
If used with swebs (i.e., Caucus), it evaluates to an empty string.

<P><DT><A NAME="readfile">$readfile(name)</A>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B><A 
   HREF="ref402.html#protect">{protected}</A></B>
<DD>
Evaluate to the entire contents of text file <I>name</I>.&nbsp;  <I>Name</I>
should be the full pathname of a file on the server host.&nbsp;  Whereas
$file() is meant as a way to include additional CML code in a
page, $readfile() is meant for reading data that will somehow
be processed or displayed by a CML page.
<p/>
$readfile() automatically translates Windows return-newline pairs 
into single newline characters, effectively converting the read
data into unix format.

<P><DT><A NAME="write">$write(name text)</A>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B><A 
   HREF="ref402.html#protect">{protected}</A></B>
<DD>
Write <I>text</I> to file with absolute pathname <I>name</I>.&nbsp;
Overwrites previous contents of <I>name</I>, if any.

<P><DT><A NAME="append">$append(name text)</A>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B><A 
   HREF="ref402.html#protect">{protected}</A></B>
<DD>
Append <I>text</I> to file with absolute pathname <I>name</I>.

<P><DT><A NAME="dosfile">$dosfile(name)</A>
<DD>

Truncates <I>name</I> to the first 8 characters, and replaces
all dots (&quot;.&quot;) with underscores (&quot;_&quot;).&nbsp;  Useful
when <I>name</I> refers to a file on the client machine.

<P><DT><A NAME="copy2lib">$copy2lib(file libname)</A>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B><A 
   HREF="ref402.html#protect">{protected}</A></B>
<DD>
Copies <I>file</I> (a  full pathname) to a new file called <I>libname</I>,
in the Caucus file library.&nbsp;  (See the parameters Caucus_Lib and
HTTP_Lib in the swebd configuration file swebd.conf for more
information about the Caucus file library.)&nbsp;  <I>Libname</I> may
contain sub-directory names, and is always treated as relative
to the root of the Caucus file library.&nbsp;  Sub-directories are created
automatically.&nbsp;  Thus a <I>libname</I> of &quot;demo/xyz&quot;
would copy <I>file</I> to a file called &quot;xyz&quot; in a sub-directory
&quot;demo&quot; under the Caucus file library, and would automatically
create the &quot;demo&quot; directory if needed.

<P>
The function evaluates to the full URL of the newly created file,
minus the protocol (http:// or https://) part.&nbsp;
Thus it is possible to make the file immediately available
on the Web in any subsequently produced HTML.


<P><DT><A NAME="copyfile">$copyfile(source target perms)</A>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B><A 
   HREF="ref402.html#protect">{protected}</A></B>
<DD>
Copies file <I>source</I> (a full pathname) to a new file called 
<I>target</I> (also a full pathname).&nbsp;  Gives <I>target</I>
the permissions <I>perm</I>.&nbsp;
Automatically creates subdirectories in <I>target</I> if
necessary (and if possible).&nbsp;
Evaluates to 1 on success, -1 if the <I>source</I> could not
be opened, or 0 if the <I>target</I> could not be written.
<P>
The value of <I>perms</I> is a "permissions mask" that is the sum
of some or all of the values below.&nbsp; This mask is
mapped directly into Unix file permission values, and as closely
as possible to the equivalent Windows/NT permissions.
<UL>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD>400</TD>  <TD>&nbsp; </TD> <TD>read by owner</TD>
<TR><TD>200</TD>  <TD></TD>  <TD>write by owner</TD>
<TR><TD>100</TD>  <TD></TD>  <TD>execute by owner</TD>
<TR><TD ALIGN=right>40</TD>  <TD></TD>  <TD>read by group</TD>
<TR><TD ALIGN=right>20</TD>  <TD></TD>  <TD>write by group</TD>
<TR><TD ALIGN=right>10</TD>  <TD></TD>  <TD>execute by group</TD>
<TR><TD ALIGN=right>4</TD>  <TD></TD>  <TD>read by anyone</TD>
<TR><TD ALIGN=right>2</TD>  <TD></TD>  <TD>write by anyone</TD>
<TR><TD ALIGN=right>1</TD>  <TD></TD>  <TD>execute by anyone</TD>
</TABLE>
</UL>


<P><DT><A NAME="mkdir">$mkdir(fullpathname [perms])</A>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B><A 
   HREF="ref402.html#protect">{protected}</A></B>
<DD>
Attempts to create a directory <i>fullpathname</i> with
(optional) permission mask <i>perms</i> (as described above).&nbsp;
Creates all of the parent directories, if needed.&nbsp;
Evaluates to 1 if successful, otherwise 0.

<P><DT><A NAME="open">$open(name perm)</A>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B><A 
   HREF="ref402.html#protect">{protected}</A></B>
<DD>
Open a file <I>name</I> for reading (if <I>perm</I> is &quot;r&quot;),
for writing (if <I>perm</I> is &quot;w&quot;), or  to append to
(if <I>perm</I> is &quot;a&quot;).&nbsp;  Evaluates to a number which
is the file &quot;handle&quot;, or to &quot;0&quot; if the  file
could not be opened.

<P><DT><A NAME="readln">$readln(handle var)</A>
<DD>
Read a line from the file open on <I>handle</I>, and put the
text into variable <I>var</I>.&nbsp;  Evalutes to &quot;1&quot; if successful,
or to &quot;0&quot; on end-of-file.

<P><DT><A NAME="writeln">$writeln(handle text)</A>
<DD>
Writes <I>text</I> to the file open on <I>handle</I>.&nbsp;  Evaluates
to &quot;1&quot; on success, or &quot;0&quot; if <I>handle</I>
does not refer to an open file.

<P><DT><A NAME="close">$close(handle)</A>
<DD>
Close file open on <I>handle</I>.

<P><DT><A NAME="exists">$exists(name)</A>
<DD>
Evaluates to &quot;1&quot; if file <i>name</i> (full pathname)
exists, and &quot;0&quot; otherwise.

<P><DT><A NAME="rename">$rename(a b)</A>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B><A 
   HREF="ref402.html#protect">{protected}</A></B>
<DD>
Rename file <I>a</I> to file <I>b</I>.

<P><DT><A NAME="delfile">$delfile(a)</A>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B><A 
   HREF="ref402.html#protect">{protected}</A></B>
<DD>
Delete file <I>a</I>.&nbsp;  Must use full pathname of file.

<P><DT><A NAME="deldir">$deldir(a)</A>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B><A 
   HREF="ref402.html#protect">{protected}</A></B>
<DD>
Delete directory <I>a</I>, and <B>all</B> contained files and
subdirectories.&nbsp;  Must use full pathname of directory.&nbsp;
<B><I>Use with caution!</I></B>

<P><DT><A NAME="file_data">$file_data(name bytes range...)</A>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B><A 
   HREF="ref402.html#protect">{protected}</A></B>
<DD>
Checks the first <I>bytes</I> characters of file <I>name</I> to 
see if its contents fit within certain byte-value ranges.&nbsp;
(A <I>bytes</I> value of -1 means "check the entire file".)
<P>
<I>Range</I> is one or more byte values or byte value ranges,
expressed as decimal numbers.&nbsp;
For example "32" is the decimal code for a "blank" character,
and the range "65-90" covers the codes for the upper-case
letters A through Z.
<P>
$file_data() evaluates to 1 if the first <I>bytes</I> characters
of <I>name</I> are included in the <I>range</I> values,
and 0 otherwise.&nbsp;
Thus, for example, $file_data(name 500 32 65-90) would evaluate to 1
if the first 500 characters were either blanks or the letters A-Z, and
0 otherwise.&nbsp;
<P>
A good use of $file_data() is to determine if a file contains
only "plain text", or is some other kind of file (word processor
file, image file, etc.)&nbsp;
If $file_data (name -1 9-26 32-126) is 1, <I>name</I> is most likely
a text file.
<P>

<P><DT><A NAME="dirlist">$dirlist(format dir)</A>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B><A 
   HREF="ref402.html#protect">{protected}</A></B>
<DD>
If <I>format</I> is 0, evaluates to a space-separated list of
the files (and directories) in directory <I>dir</I>.&nbsp;  If <I>format</I>
is 1, each filename is immediately followed by a space and the
size of the file in bytes.&nbsp;
If <I>format</I> is 2, each filename is followed by a space, the size,
another space, and a directory code (1 means the filename is a directory,
0 means it is an ordinary file).

<P><DT><A NAME="output">$output(name mask)</A>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B><A 
   HREF="ref402.html#protect">{protected}</A></B>
<DD>
Normally, CML lines that begin with a double-quote (&quot;) are
interpreted and sent directly to the user's browser.&nbsp;  The  $output()
function redirects this text, and writes it to a file <I>name</I>,
instead.&nbsp;  <I>Mask</I> is the numeric Unix file permission mask,
e.g. a value of &quot;644&quot; (decimal!) means read/write owner, read group,
and read world.&nbsp;
(The file is created &amp; truncated each time this is done, so subsequent
$output()'s to the same file rewrite it each time.)

<P>
The redirection takes effect on all quoted lines that follow
the use of $output().&nbsp;  Another call to $output(), with no arguments,
returns subsequent output from quoted lines to the browser, in
effect &quot;closing&quot; the  file.

</DL>
</BLOCKQUOTE>

<P>
<HR>
</BODY>
</HTML>
