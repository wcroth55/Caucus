/***  emailparser.   Implementations of CML email participation functions.
/
/   Purpose: 
/      Caucus needs to be able to send out HTML email ("email participation")
/      and then parse replies sent back by email clients.  The HTML generated by 
/      different email clients (such as Microsoft Outlook) can be quite complex.  
/      Preparing the outgoing email so that it can be parsed, and then fetching and
/      extracting the actual email text, and separating it from the original 
/      "replied to" or "quoted" text, is even more complicated.
/
/   How it works:
/      Implements the core of $email_start() and $email_stop(), which provide magic 
/      "boundary" strings that go around the text of outgoing email participation emails.
/
/      Implements extractNewTextFromPlainEmailReply(), which is the core of
/      $email_extract(), which plucks out the new text in the incoming reply *to*
/      a previously sent outgoing participation email.
/
/   Notes:
/      1. Assumes that only "=" are hex-encoded (could be very wrong!)
/
/   Copyright (C) 2003-2007 CaucusCare.com.  All rights reserved.
/    This program is published under the terms of the GPL; see
/    the file license.txt in the same directory. 
/
/   Version history:
/:CR  4/07/2007.  Major rewrite of old email participation code.
/:CR 10/17/2007.  Fix "wrote:" detection, strip <blockquote cite="mid...">'s
/:CR 11/18/2007.  Fix bug in removal of <o:p>'s; remove <hr tabindex=-1>'s.
/ */

#include <stdio.h>
#include "chixuse.h"
#include "sweb.h"

int  getEntireTagByName();
void extractTagOpenThruTagClose();
void removeTagOpenThruTagClose();
void undoHexEncodingOfText();
void HtmlTagsToLowercase();
void extractNewTextFromHtmlEmailReply();
void removeInnermostTagContainingEmailHeader();
void removeLineBreaksInsideSpanTags();
void removeGmailHeader();
void removeTextBetweenBoundarySignatureDivs();
void removeOriginalTextSpans();
Chix makeTag();

#define CaucusTextSpan          "<span class=\"caucus\">"
#define CaucusTextSpanNoQuotes  "<span class=caucus>"
#define LowerBound     "&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;"
#define UpperBound     "&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;"

#define FALSE   0
#define TRUE    1

FUNCTION char *lowerBoundary() {
   return "<div style=\"display: none;\">" LowerBound "</div>" CaucusTextSpan;
}

FUNCTION char *upperBoundary() {
   return "</span>" "<div style=\"display: none;\">" UpperBound "</div>";
}

#if 0
FUNCTION void etest (Chix result, Chix arg) {
   Chix word1, word2, rest;
   int4 value;
   int  num;
   char temp[200];

   word1 = chxalloc (20L, THIN, "word1");
   word2 = chxalloc (20L, THIN, "word2");
   rest = chxalloc (30L, THIN, "rest");
   chxtoken (word1, nullchix, 1, arg);
   chxtoken (word2, nullchix, 2, arg);
   chxtoken (nullchix, rest, 3, arg);

   extractNewTextFromHtmlEmailReply (result, rest, word2);
}
#endif

FUNCTION void extractNewTextFromHtmlEmailReply (Chix result, Chix emailText, Chix emailAddress) {
   static Chix temp = nullchix;
   static Chix divTag, pTag, opTag, aTag, empty, bodyTag, blockquoteTag, hrTag;
   int pos, outlookVersion, opPos, senderLinkPos, wrotePos, blockquotePos;
   int hrPos, hrLen;

   if (temp == nullchix) {
      temp    = chxalloc (L(2000), THIN, "extractNewTextFromHtmlEmailReply temp");
      empty   = chxalloc (L(2),    THIN, "extractNewTextFromHtmlEmailReply empty");
      divTag  = chxalsub (CQ("div"),  L(0), L(20));
      pTag    = chxalsub (CQ("p"),    L(0), L(20));
      aTag    = chxalsub (CQ("a"),    L(0), L(20));
      opTag   = chxalsub (CQ("o:p"),  L(0), L(20));
      hrTag   = chxalsub (CQ("hr"),   L(0), L(20));
      bodyTag = chxalsub (CQ("body"), L(0), L(20));
      blockquoteTag = chxalsub (CQ("blockquote"), L(0), L(20));
   }

   chxcpy (result, emailText);
   undoHexEncodingOfText (result);

   HtmlTagsToLowercase (result);

   removeLineBreaksInsideSpanTags (result);

   outlookVersion = microsoftOutlookVersion (result);
   if (outlookVersion >= 2003) {
      /* ---Rule 1: keep contents of outermost div, throw everything else away. */
      extractTagOpenThruTagClose (temp, result, divTag, 0, FALSE);
      chxcpy (result, temp);
   }

   if (outlookVersion > 0) {
      /* ---Rule 2: remove everything between the <div>s that contain the lower and
      /  upper "boundary signatures" which are "invisible" markers that should bound
      /  the entire original text. */
      removeTextBetweenBoundarySignatureDivs (result);

      /*---Rule 3: In case any original text managed to slip outside the boundary
      /    signatures, remove all <span class=originaltext>'s and contents as well. */
      removeOriginalTextSpans (result);

      /*---Rule 4: remove the innermost <div> or <p> containing our email address & headers. */
      removeInnermostTagContainingEmailHeader (result, divTag, emailAddress);
      removeInnermostTagContainingEmailHeader (result, pTag,   emailAddress);

      /*---Rule 5: remove all <o:p>...</o:p> sets, just because they're ugly and unpredictable. */
      for (pos=0;   (opPos = chxindex (result, pos, opTag)) > 0;   pos = opPos) {
         removeTagOpenThruTagClose (result, opTag, pos);
      }

      /*---Rule 6: remove weird <hr tabindex=-1>, Outlook put it there. */
      hrPos = getEntireTagByName (temp, result, hrTag, 0);
      if (chxindex (temp, L(0), CQ("tabindex=-1")) >= 0) {
         hrLen = chxlen(temp);
         chxcpy    (temp, result);
         chxclear  (result);
         chxcatsub (result, temp, L(0), hrPos);
         chxcatsub (result, temp, hrPos + hrLen, ALLCHARS);
      }
   }

   else if (isMozilla (result)) {
      /*---Rule 1: extract contents of body, throw away all original text <span>s. */
      extractTagOpenThruTagClose (temp, result, bodyTag, 0, FALSE);
      chxcpy (result, temp);
      removeOriginalTextSpans (result);

      /*---Rule 2: remove special "<a>sender's email address</a> wrote:" text. */
      senderLinkPos = chxindex (result, L(0), CQ("<a class=\"moz-txt-link-abbreviated\""));
      if (senderLinkPos > 0) {
         removeTagOpenThruTagClose (result, aTag, senderLinkPos);
         wrotePos = chxindex (result, senderLinkPos, CQ("wrote:"));
         if (wrotePos - senderLinkPos >= 0  &&  wrotePos - senderLinkPos < 3) {
            chxalter (result, senderLinkPos, CQ("wrote:"), empty);
         }
      }

      /*---Rule 3: remove text inside <blockquote cite="mid:...">...</blockquote> */
      blockquotePos = chxindex (result, L(0), CQ("<blockquote cite=\"mid"));
      if (blockquotePos >= 0) {
         removeTagOpenThruTagClose (result, blockquoteTag, blockquotePos);
      }
   }

   /*---Other email clients: hope that they play nicely with HTML.
   /    Grab the body text, and strip out original ("quoted") text. (Firefox Rule 1.) */
   else {
      extractTagOpenThruTagClose (temp, result, bodyTag, 0, FALSE);
      if (chxlen(temp) > 0)  chxcpy (result, temp);
      removeOriginalTextSpans (result);
      removeTextBetweenBoundarySignatureDivs (result);
      removeGmailHeader (result);
   }

   return;
}

/*---Some email clients encode normal characters as "=xx" hex encodings.  Outlook
/    often does this if a file was attached.  Undo the encodings.  Heuristic: if
/    there are 3 or more "=3D"s (which is itself an equal sign), assume the encoding
/    needs to be undone. */
FUNCTION void undoHexEncodingOfText (Chix emailText) {
   static Chix equal3D = nullchix;
   static Chix equal, equalNl, empty;
   int    count3D, pos;

   if (equal3D == nullchix) {
      equal3D = chxalsub (CQ("=3D"), L(0), L(20));
      equalNl = chxalsub (CQ("=\n"), L(0), L(20));
      equal   = chxalsub (CQ("="),   L(0), L(20));
      empty   = chxalloc (L(4), THIN, "undoHexEncodingOfText empty");
   }

   pos = 0;
   for (count3D=0;   count3D < 3;   ++count3D) {
      if ( (pos = chxindex (emailText, pos, equal3D)) < 0)  return;
      ++pos;
   }

   chxreplace (emailText, L(0), equal3D, equal);
   chxreplace (emailText, L(0), equalNl, empty);
   return;
}


FUNCTION void HtmlTagsToLowercase (Chix htmlText) {
   int len, state, i, c, type;

   len  = chxlen (htmlText);
   type = chxtype(htmlText);

   /*---Finite state machine: 0=outside tag, 1=inside tag/lowercase, 2=inside tag/skip. */
   state = 0;  
   for (i=0;   i<len;   ++i) {
      c = chxvalue (htmlText, i);
      if (state == 0) {
         if (c == '<')  state = 1;
      }
      else if (state == 1) {
         if      (c == '/') ;
         else if (cf_upper (c))  chxsetval (htmlText, i, type, c + ('a' - 'A'));
         else if (cf_lower (c))  ;
         else if (c == '>')      state = 0;
         else                    state = 2;
      }
      else if (state == 2) {
         if (c == '>')  state = 0;
      }
   }
   return;
}
FUNCTION void removeInnermostTagContainingEmailHeader (Chix emailText, 
			Chix tag, Chix emailAddress) {
   static Chix contents = nullchix;
   static Chix mailto, sent, subject;
   int tagPos, pos;

   if (contents == nullchix) {
      contents = chxalloc (L(400), THIN, "removeInnermostTagContainingEmailHeader contents");
      mailto   = chxalloc (L(400), THIN, "removeInnermostTagContainingEmailHeader mailto");
      sent     = chxalsub (CQ("Sent:"),    L(0), L(20));
      subject  = chxalsub (CQ("Subject:"), L(0), L(20));
   }
   chxcpy (mailto, CQ("mailto:"));
   chxcat (mailto, emailAddress);

   for (pos=0;   (tagPos = indexOfTag (emailText, tag, pos)) > 0;   pos = tagPos + 1) {

      extractTagOpenThruTagClose (contents, emailText, tag, tagPos, FALSE);
      if (indexOfTag (contents, tag, 0) >= 0)  continue;  /* Only consider innermost tags. */

      if (chxindex (contents, L(0), mailto) >= 0  &&
          chxindex (contents, L(0), sent)   >= 0  &&  chxindex (contents, L(0), subject) >= 0) {

         removeTagOpenThruTagClose (emailText, tag, tagPos);
         break;
      }
   }
}

FUNCTION void removeLineBreaksInsideSpanTags (Chix emailText) {
   static Chix span = nullchix;
   static Chix span1, span2;

   if (span == nullchix) {
      span  = chxalsub (CQ("<span "),   L(0), L(20));
      span1 = chxalsub (CQ("<span\n"),  L(0), L(20));
      span2 = chxalsub (CQ("<span \n"), L(0), L(20));
   }

   chxreplace (emailText, L(0), span2, span);
   chxreplace (emailText, L(0), span1, span);
}

FUNCTION void removeGmailHeader (Chix emailText) {
   int  pos, gmailPos;
   Chix span;

   span = chxalsub (CQ("span"), L(0), L(20));

   for (pos=0;   (gmailPos = chxindex (emailText, pos, CQ("<span class=\"gmail_quote\""))) > 0;
                  pos = gmailPos)
      removeTagOpenThruTagClose (emailText, span, gmailPos);

   chxfree (span);
   return;
}


FUNCTION void removeTextBetweenBoundarySignatureDivs (Chix emailText) {
   static Chix divTag = nullchix;
   static Chix div, blank, newline, blank2, lowBound, upBound, temp;
   int         upperPos = -1;
   int         lowerPos = -1;
   int         divPos, pos;

   if (divTag == nullchix) {
      divTag   = chxalsub (CQ("div"), L(0), L(20));
      blank    = chxalsub (CQ(" "),   L(0), L(20));
      blank2   = chxalsub (CQ("  "),  L(0), L(20));
      newline  = chxalsub (CQ("\n"),  L(0), L(20));
      lowBound = chxalsub (CQ(LowerBound), L(0), L(100));
      upBound  = chxalsub (CQ(UpperBound), L(0), L(100));
      div      = chxalloc (chxlen(emailText), THIN, "removeTextBetweenBoundarySignatureDivs div");
      temp     = chxalloc (chxlen(emailText), THIN, "removeTextBetweenBoundarySignatureDivs temp");
   }

   for (pos=0;   (divPos = indexOfTag (emailText, divTag, pos)) > 0;   pos = divPos + 1) {

      extractTagOpenThruTagClose (div, emailText, divTag, divPos, FALSE);
      if (indexOfTag (div, divTag, 0) >= 0)  continue;  /* Only consider innermost div's. */

      chxreplace (div, L(0), newline, blank);
      chxreplace (div, L(0), blank2,  blank);
      chxreplace (div, L(0), blank2,  blank);

      if (lowerPos < 0  &&  chxindex(div, L(0), lowBound) >= 0)  lowerPos = divPos;
      else              if (chxindex(div, L(0), upBound)  >= 0)  upperPos = divPos;
   }

   if (upperPos < 0  ||  lowerPos < 0)  return;

   removeTagOpenThruTagClose (emailText, divTag, upperPos);
   chxclear  (temp);
   chxcatsub (temp, emailText, L(0), lowerPos);
   chxcatsub (temp, emailText, upperPos, ALLCHARS);
   chxcpy    (emailText, temp);

   return;
}

FUNCTION void removeOriginalTextSpans (Chix emailText) {
   int pos, originalPos;
   Chix span;

   span = chxalsub (CQ("span"), L(0), L(20));

   for (pos=0;   (originalPos = chxindex (emailText, pos, CQ(CaucusTextSpan))) > 0;
                  pos = originalPos)
      removeTagOpenThruTagClose (emailText, span, originalPos);

   for (pos=0;   (originalPos = chxindex (emailText, pos, CQ(CaucusTextSpanNoQuotes))) > 0;
                  pos = originalPos)
      removeTagOpenThruTagClose (emailText, span, originalPos);

   chxfree (span);
   return;
}

FUNCTION int microsoftOutlookVersion (Chix emailText) {
   int  version = 0;
   Chix tagName, tagText;
   tagText = chxalloc (L(20), THIN, "microsoftOutlookVersion tagText");

   tagName = chxalsub (CQ("html"), L(0), L(20));
   getEntireTagByName (tagText, emailText, tagName, 0);
   if (chxindex (tagText, L(0), CQ("urn:schemas-microsoft-com")) > 0)     version = 2007;

   if (version == 0) {
      chxcpy (tagName, CQ("p"));
      extractTagOpenThruTagClose (tagText, emailText, tagName, 0, TRUE);
      if (chxindex (tagText, L(0), CQ("class=MsoNormal")) > 0)            version = 2003;
   }

   if (version == 0  &&
      chxindex (emailText, L(0), CQ("class=OutlookMessageHeader")) >= 0)  version = 2000;

   chxfree (tagText);
   chxfree (tagName);
   return version;
}

FUNCTION int isMozilla (Chix text) {
   return (chxindex (text, L(0), CQ("class=\"moz-txt-link-abbreviated\"")) > 0);
}


FUNCTION int getEntireTagByName (Chix result, Chix text, Chix tagname, int startPos) {
   int  pos, endTagPos;
   Chix tag;

   chxclear (result);
   tag = makeTag  ("<", tagname, "");
   pos = chxindex (text, startPos, tag);
   if (pos >= 0) {
      endTagPos = chxindex (text, pos+1, CQ(">"));
      if (endTagPos >= 0) chxcatsub (result, text, pos, endTagPos+1-pos);
   }
   chxfree (tag);
   return pos;
}

FUNCTION void extractTagOpenThruTagClose (Chix result, Chix text, Chix tag, int startPos, 
                                           int keepTags) {
   int pos, endPos;
   Chix  temp;

   pos = indexOfTag (text, tag, startPos);
   if (pos < 0)    { chxclear (result);   return; }

   endPos = findPositionOfTagClose (text, tag, pos);
   if (endPos < 0) { chxclear (result);   return; }

   temp = chxalloc (chxlen(text), THIN, "extractTagOpenThruTagClose temp");
   chxcatsub (temp, text, pos, endPos+1-pos);
   chxcpy    (result, temp);
   
   if (! keepTags) {
      pos = chxindex (result, L(0), CQ(">"));
      if (pos >= 0) {
         chxclear  (temp);
         chxcatsub (temp, result, pos+1, ALLCHARS);
         chxcpy    (result, temp);
      }
      pos = chxrevdex (result, ALLCHARS, CQ("<"));
      if (pos >= 0) {
         chxclear  (temp);
         chxcatsub (temp, result, 0, pos);
         chxcpy    (result, temp);
      }
   }

   chxfree (temp);
   return;
}

FUNCTION void removeTagOpenThruTagClose (Chix text, Chix tag, int startPos) {
   int pos, endPos;
   Chix temp;

   pos = indexOfTag (text, tag, startPos);
   if (pos < 0)  return;

   endPos = findPositionOfTagClose (text, tag, pos);
   if (endPos < 0)  return;

   temp = chxalloc (chxlen(text), THIN, "removeTagOpenThruTagClose temp");
   chxcatsub (temp, text, 0, pos);
   chxcatsub (temp, text, endPos+1, ALLCHARS);
   chxcpy    (text, temp);
   chxfree   (temp);

   return;
}


FUNCTION int indexOfTag (Chix text, Chix tag, int startPos) {
   Chix tagNormal, tagBlank;
   int  simpleTagPos, qualifiedTagPos, index;

   tagNormal = makeTag ("<", tag, ">");
   tagBlank  = makeTag ("<", tag, " ");

   simpleTagPos    = chxindex (text, startPos, tagNormal);
   qualifiedTagPos = chxindex (text, startPos, tagBlank);
   if (simpleTagPos < 0  &&  qualifiedTagPos < 0)  index = -1;
   else {
      if (simpleTagPos    < 0)  simpleTagPos    = chxlen(text);
      if (qualifiedTagPos < 0)  qualifiedTagPos = chxlen(text);
      index = (simpleTagPos < qualifiedTagPos ? simpleTagPos : qualifiedTagPos);
   }

   chxfree (tagNormal);
   chxfree (tagBlank);
   return index;
}

FUNCTION Chix makeTag (char *prefix, Chix tag, char *suffix) {
   Chix result;
   result = chxalloc (L(20), THIN, "makeTag");
   chxcpy (result, CQ(prefix));
   chxcat (result, tag);
   chxcat (result, CQ(suffix));

   return  result;
}

FUNCTION int findPositionOfTagClose (Chix text, Chix tag, int tagStartPos) {
   int tagDepth = 0;
   int pos, tagEndPos;
   Chix openTag, closeTag;

   openTag  = makeTag ("<",  tag, "");
   closeTag = makeTag ("</", tag, "");

   int textLength = chxlen(text);
   tagEndPos = -1;
   for (pos=tagStartPos;   pos < textLength;   ++pos) {
      if      (chxsubeq (text, pos, openTag))  ++tagDepth;
      else if (chxsubeq (text, pos, closeTag)) {
         --tagDepth;
         if (tagDepth == 0) {
            tagEndPos = chxindex (text, pos, CQ(">"));
            break;
         }
      }
   }
   chxfree (openTag);
   chxfree (closeTag);
   return tagEndPos;
}

FUNCTION void fixKnownEmailClientHtmlBugs (Chix text) {
   static Chix title1 = nullchix;
   static Chix title2;

   if (title1 == nullchix) {
      title1 = chxalsub (CQ("</TITLE<!"),   L(0), L(20));
      title2 = chxalsub (CQ("</TITLE><!"),  L(0), L(20));
   }

   if (EMPTYCHX (text))  return;
   chxreplace (text, L(0), title1, title2); /* Blackberry email client bug. */
}
